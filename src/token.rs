#[derive(Debug, PartialEq, Clone)]
pub enum Token {
    LeftParen { line: usize },
    RightParen { line: usize },
    LeftBrace { line: usize },
    RightBrace { line: usize },
    Comma { line: usize },
    Dot { line: usize },
    Minus { line: usize },
    Plus { line: usize },
    Semicolon { line: usize },
    Slash { line: usize },
    Star { line: usize },
    Bang { line: usize },
    BangEqual { line: usize },
    Equal { line: usize },
    EqualEqual { line: usize },
    Greater { line: usize },
    GreaterEqual { line: usize },
    Less { line: usize },
    LessEqual { line: usize },
    Identifier(Identifier),
    String { value: String, line: usize },
    Number { value: f64, line: usize },
    And { line: usize },
    Class { line: usize },
    Else { line: usize },
    False { value: bool, line: usize },
    Fun { line: usize },
    For { line: usize },
    If { line: usize },
    Nil { line: usize },
    Or { line: usize },
    Print { line: usize },
    Return { line: usize },
    Super { line: usize },
    This { line: usize },
    True { value: bool, line: usize },
    Var { line: usize },
    While { line: usize },
    Eof,
}

#[derive(Debug, PartialEq, Clone)]
pub struct Identifier {
    pub value: String,
    pub line: usize,
}

impl std::fmt::Display for Identifier {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "Identifier({}): {}", self.line, self.value)
    }
}

impl std::fmt::Display for Token {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            Token::LeftParen { line } => write!(f, "LeftParen({})", line),
            Token::RightParen { line } => write!(f, "RightParen({})", line),
            Token::LeftBrace { line } => write!(f, "LeftBrace({})", line),
            Token::RightBrace { line } => write!(f, "RightBrace({})", line),
            Token::Comma { line } => write!(f, "Comma({})", line),
            Token::Dot { line } => write!(f, "Dot({})", line),
            Token::Minus { line } => write!(f, "Minus({})", line),
            Token::Plus { line } => write!(f, "Plus({})", line),
            Token::Semicolon { line } => write!(f, "Semicolon({})", line),
            Token::Slash { line } => write!(f, "Slash({})", line),
            Token::Star { line } => write!(f, "Star({})", line),
            Token::Bang { line } => write!(f, "Bang({})", line),
            Token::BangEqual { line } => write!(f, "BangEqual({})", line),
            Token::Equal { line } => write!(f, "Equal({})", line),
            Token::EqualEqual { line } => write!(f, "EqualEqual({})", line),
            Token::Greater { line } => write!(f, "Greater({})", line),
            Token::GreaterEqual { line } => write!(f, "GreaterEqual({})", line),
            Token::Less { line } => write!(f, "Less({})", line),
            Token::LessEqual { line } => write!(f, "LessEqual({})", line),
            Token::Identifier(identifier) => {
                write!(f, "Identifier({}): {}", identifier.line, identifier.value)
            }
            Token::String { value, line } => write!(f, "String({}): {}", line, value),
            Token::Number { value, line } => write!(f, "Number({}): {}", line, value),
            Token::And { line } => write!(f, "And({})", line),
            Token::Class { line } => write!(f, "Class({})", line),
            Token::Else { line } => write!(f, "Else({})", line),
            Token::False { value, line } => write!(f, "False({}): {}", line, value),
            Token::Fun { line } => write!(f, "Fun({})", line),
            Token::For { line } => write!(f, "For({})", line),
            Token::If { line } => write!(f, "If({})", line),
            Token::Nil { line } => write!(f, "Nil({})", line),
            Token::Or { line } => write!(f, "Or({})", line),
            Token::Print { line } => write!(f, "Print({})", line),
            Token::Return { line } => write!(f, "Return({})", line),
            Token::Super { line } => write!(f, "Super({})", line),
            Token::This { line } => write!(f, "This({})", line),
            Token::True { value, line } => write!(f, "True({}): {}", value, line),
            Token::Var { line } => write!(f, "Var({})", line),
            Token::While { line } => write!(f, "While({})", line),
            Token::Eof => write!(f, "Eof"),
        }
    }
}

impl Token {
    pub fn line(&self) -> usize {
        match self {
            Token::LeftParen { line } => *line,
            Token::RightParen { line } => *line,
            Token::LeftBrace { line } => *line,
            Token::RightBrace { line } => *line,
            Token::Comma { line } => *line,
            Token::Dot { line } => *line,
            Token::Minus { line } => *line,
            Token::Plus { line } => *line,
            Token::Semicolon { line } => *line,
            Token::Slash { line } => *line,
            Token::Star { line } => *line,
            Token::Bang { line } => *line,
            Token::BangEqual { line } => *line,
            Token::Equal { line } => *line,
            Token::EqualEqual { line } => *line,
            Token::Greater { line } => *line,
            Token::GreaterEqual { line } => *line,
            Token::Less { line } => *line,
            Token::LessEqual { line } => *line,
            Token::Identifier(identifier) => identifier.line,
            Token::String { value: _, line } => *line,
            Token::Number { value: _, line } => *line,
            Token::And { line } => *line,
            Token::Class { line } => *line,
            Token::Else { line } => *line,
            Token::False { value: _, line } => *line,
            Token::Fun { line } => *line,
            Token::For { line } => *line,
            Token::If { line } => *line,
            Token::Nil { line } => *line,
            Token::Or { line } => *line,
            Token::Print { line } => *line,
            Token::Return { line } => *line,
            Token::Super { line } => *line,
            Token::This { line } => *line,
            Token::True { value: _, line } => *line,
            Token::Var { line } => *line,
            Token::While { line } => *line,
            Token::Eof => 0,
        }
    }

    pub fn lexeme(&self) -> String {
        match self {
            Token::LeftParen { line: _ } => "(".to_string(),
            Token::RightParen { line: _ } => ")".to_string(),
            Token::LeftBrace { line: _ } => "{".to_string(),
            Token::RightBrace { line: _ } => "}".to_string(),
            Token::Comma { line: _ } => ",".to_string(),
            Token::Dot { line: _ } => ".".to_string(),
            Token::Minus { line: _ } => "-".to_string(),
            Token::Plus { line: _ } => "+".to_string(),
            Token::Semicolon { line: _ } => ";".to_string(),
            Token::Slash { line: _ } => "/".to_string(),
            Token::Star { line: _ } => "*".to_string(),
            Token::Bang { line: _ } => "!".to_string(),
            Token::BangEqual { line: _ } => "!=".to_string(),
            Token::Equal { line: _ } => "=".to_string(),
            Token::EqualEqual { line: _ } => "==".to_string(),
            Token::Greater { line: _ } => ">".to_string(),
            Token::GreaterEqual { line: _ } => ">=".to_string(),
            Token::Less { line: _ } => "<".to_string(),
            Token::LessEqual { line: _ } => "<=".to_string(),
            Token::Identifier(identifier) => identifier.value.clone(),
            Token::String { value, line: _ } => value.clone(),
            Token::Number { value, line: _ } => value.to_string(),
            Token::And { line: _ } => "and".to_string(),
            Token::Class { line: _ } => "class".to_string(),
            Token::Else { line: _ } => "else".to_string(),
            Token::False { value: _, line: _ } => "false".to_string(),
            Token::Fun { line: _ } => "fun".to_string(),
            Token::For { line: _ } => "for".to_string(),
            Token::If { line: _ } => "if".to_string(),
            Token::Nil { line: _ } => "nil".to_string(),
            Token::Or { line: _ } => "or".to_string(),
            Token::Print { line: _ } => "print".to_string(),
            Token::Return { line: _ } => "return".to_string(),
            Token::Super { line: _ } => "super".to_string(),
            Token::This { line: _ } => "this".to_string(),
            Token::True { value: _, line: _ } => "true".to_string(),
            Token::Var { line: _ } => "var".to_string(),
            Token::While { line: _ } => "while".to_string(),
            Token::Eof => "".to_string(),
        }
    }
}
